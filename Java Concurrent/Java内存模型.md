# Java内存模型
## Java内存模型的基础
### 并发编程模型的两个关键问题
1. **线程之间的通信**  
    * 共享内存
    * 消息传递
2. **线程之间的同步**
    * 在共享内存并发模型中，同步是显示进行的
    * 在消息传递并发模型中，由于消息的发送必须在消息的接收之前，同步是隐式进行
***
### Java内存模型的抽象结构

实例域，静态域和数组存储在堆内存中，多线程共享（共享变量）。
局部变量，方法定义参数和异常处理器参数不在线程之间共享。

**Java线程之间的通信由Java内存模型JMM控制,JMM决定一个线程对共享变量的写入何时对另一个线程可见**
* JMM定义了线程和主内存之间的抽象关系
    线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。
  * 本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化

* JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。
***
### 从源代码到指令序列的重排序
1. **编译器优化的重排序**
编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
2. **指令级并行的重排序**
现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. **内存系统的重排序**
由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过**内存屏障指令**来禁止特定类型的处理器重排序。
***
### happens-before简介
* the first is visible to and ordered before the second
* 一个happens-before规则对应于一个或多个编译器和处理器重排序规则

1. **程序顺序规则**
 一个线程中的每个操作，happens-before于线程中的任意后续操作
2. **监视器锁规则**
对一个锁的解锁，happens-before于随后对这个锁的加锁
3. **volatile变量规则**
对一个volatile域的写，happens-before于任意后续对这个volatile域的读
4. **传递性**
***

https://www.jianshu.com/p/8a58d8335270